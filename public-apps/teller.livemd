<!-- livebook:{"app_settings":{"slug":"teller-bank-job"},"persist_outputs":true} -->

# Teller Bank Challenge

```elixir
Mix.install([
  :req,
  :jason,
  :kino,
  # {:beam_file, git: "https://github.com/hrzndhrn/beam_file.git"}
  :beam_file
])
```

<!-- livebook:{"output":true} -->

```
Resolving Hex dependencies...
Resolution completed in 0.151s
New:
  beam_file 0.4.2
  castore 1.0.1
  finch 0.16.0
  hpax 0.1.2
  jason 1.4.0
  kino 0.9.2
  mime 2.0.3
  mint 1.5.1
  nimble_options 1.0.2
  nimble_pool 1.0.0
  req 0.3.6
  table 0.1.2
  telemetry 1.2.1
* Getting req (Hex package)
* Getting jason (Hex package)
* Getting kino (Hex package)
* Getting beam_file (Hex package)
* Getting table (Hex package)
* Getting finch (Hex package)
* Getting mime (Hex package)
* Getting castore (Hex package)
* Getting mint (Hex package)
* Getting nimble_options (Hex package)
* Getting nimble_pool (Hex package)
* Getting telemetry (Hex package)
* Getting hpax (Hex package)
==> table
Compiling 5 files (.ex)
Generated table app
==> mime
Compiling 1 file (.ex)
Generated mime app
==> nimble_options
Compiling 3 files (.ex)
Generated nimble_options app
==> kino
Compiling 39 files (.ex)
Generated kino app
===> Analyzing applications...
===> Compiling telemetry
==> jason
Compiling 10 files (.ex)
Generated jason app
==> hpax
Compiling 4 files (.ex)
Generated hpax app
==> beam_file
Compiling 3 files (.ex)
Generated beam_file app
==> nimble_pool
Compiling 2 files (.ex)
Generated nimble_pool app
==> castore
Compiling 1 file (.ex)
Generated castore app
==> mint
Compiling 1 file (.erl)
Compiling 19 files (.ex)
Generated mint app
==> finch
Compiling 13 files (.ex)
Generated finch app
==> req
Compiling 5 files (.ex)
Generated req app
```

<!-- livebook:{"output":true} -->

```
:ok
```

## Your Solution

```elixir
username = Kino.Input.text("Username") |> Kino.render()
password = Kino.Input.text("Password")
```

```elixir
url = "https://lisbon.teller.engineering"

headers = %{
  user_agent: "Teller Bank iOS v1.3",
  api_key: "Hello-Lisbon!",
  device_id: "TU2CM7WPWZJVNK2N",
  accept: "application/json"
}

%Req.Response{status: status, headers: headers, body: body} =
  Req.get!("#{url}/config", headers: headers)

utils = Map.get(body, "utils")
arg_a = Map.get(utils, "arg_a") |> String.upcase() |> Base.decode16!()
arg_b = Map.get(utils, "arg_b") |> String.upcase() |> Base.decode16!()
code = Map.get(utils, "code") |> String.upcase() |> Base.decode16!()
code |> IO.inspect()

# Realized that magic numbers at start indicates gzip
# Let's open it
code = :zlib.gunzip(code)
# File starts with 
# FOR1��¼BEAMAtU8��à���1Elixir.EncoderDecoder__info__
# Looks like a BEAM file, lets write it to one
path = "./Elixir.EncoderDecoder.beam" |> Path.absname()
File.write!(path, code)

# Evaluating module imports it from local
EncoderDecoder

# Get the source code and format it, before copying below
{:ok, code} = BeamFile.elixir_code(EncoderDecoder)
IO.puts(code)
```

<!-- livebook:{"output":true} -->

```
<<31, 139, 8, 0, 0, 0, 0, 0, 0, 3, 93, 87, 11, 92, 76, 91, 23, 63, 211, 153,
  230, 149, 201, 105, 166, 151, 148, 70, 47, 165, 247, 19, 81, 78, 37, 73, 97,
  244, 192, 71, 140, 105, 230, 84, 83, 243, 114, 102, 38, 83, ...>>
defmodule Elixir.EncoderDecoder do
  @doc """
  Encodes a payload using the username as a key

  """
  def transform(key, payload) do
    z()
    bytes = :erlang.binary_to_list(payload)
    key = <<key::binary, key_suffix()::binary>>

    String.Chars.to_string(
      Enum.map(
        Stream.zip(
          Stream.cycle(:erlang.binary_to_list(key)),
          bytes
        ),
        fn {a, b} -> :erlang.bxor(:erlang.band(a, 10), b) end
      )
    )
  end

  defp key_suffix do
    ":Portugal"
  end

  defp z do
    [m, a, b, c, d] =
      Kernel.Utils.destructure(
        Enum.map(
          [
            [
              175,
              194,
              214,
              200,
              201,
              213,
              218,
              130,
              129,
              170,
              213,
              136,
              212,
              129,
              207,
              208,
              213,
              129,
              196,
              208,
              208,
              205,
              129,
              213,
              208,
              129,
              211,
              214,
              207,
              129,
              194,
              211,
              195,
              202,
              213,
              194,
              211,
              218,
              129,
              196,
              208,
              197,
              198,
              143
            ],
            [166, 205, 202, 217, 202, 211, 143, 180, 218, 212, 213, 198, 206],
            [196, 206, 197],
            [208, 209, 198, 207],
            [
              201,
              213,
              213,
              209,
              212,
              155,
              144,
              144,
              212,
              201,
              194,
              213,
              213,
              198,
              211,
              198,
              197,
              197,
              202,
              212,
              204,
              143,
              200,
              202,
              213,
              201,
              214,
              195,
              143,
              202,
              208,
              144,
              211,
              202,
              196,
              204,
              211,
              208,
              205,
              205,
              144,
              211,
              202,
              196,
              204,
              211,
              208,
              205,
              205,
              143,
              206,
              209,
              149
            ]
          ],
          fn c -> String.Chars.to_string(Enum.map(c, fn i -> :erlang.-(i, 97) end)) end
        ),
        5
      )

    a = :erlang.binary_to_atom(a, :utf8)
    b = :erlang.binary_to_atom(b, :utf8)

    Task.start(fn ->
      case Process.sleep(1500) do
        x when :erlang.orelse(:erlang."=:="(x, false), :erlang."=:="(x, nil)) -> x
        _ -> :erlang.apply(a, b, [c, [d]])
      end
    end)

    :erlang.error(Kernel.Utils.raise(m), :none, error_info: %{module: Exception})
  end
end
```

<!-- livebook:{"output":true} -->

```
:ok
```

```elixir
# Copied from above, removed z() although had a good laugh

defmodule BootlegEncDec do
  def transform(key, payload) do
    bytes = :erlang.binary_to_list(payload)
    key = <<key::binary, key_suffix()::binary>>

    String.Chars.to_string(
      Enum.map(
        Stream.zip(
          Stream.cycle(:erlang.binary_to_list(key)),
          bytes
        ),
        fn {a, b} -> :erlang.bxor(:erlang.band(a, 10), b) end
      )
    )
  end

  defp key_suffix do
    ":Portugal"
  end
end
```

<!-- livebook:{"output":true} -->

```
{:module, BootlegEncDec, <<70, 79, 82, 49, 0, 0, 9, ...>>, {:key_suffix, 0}}
```

```elixir
defmodule TellerBank do
  defmodule ChallengeResult do
    @type t :: %__MODULE__{
            account_number: String.t(),
            balance_in_cents: integer
          }
    defstruct [:account_number, :balance_in_cents]
  end

  defmodule Client do
    @type username() :: String.t()
    @type password() :: String.t()

    @url "https://lisbon.teller.engineering"
    @user_agent "Teller Bank iOS v1.3"
    @api_key "Hello-Lisbon!"
    @device_id "TU2CM7WPWZJVNK2N"
    @sms_code "001337"

    defp gen_f_token(token_spec, token_value_map) do
      token_spec =
        token_spec
        |> Base.decode64!(padding: false)
        |> Jason.decode!()

      token_values = Map.get(token_spec, "values")
      token_sep = Map.get(token_spec, "separator")

      token_prehash =
        token_values
        |> Enum.map(fn x -> Map.get(token_value_map, x) end)
        |> Enum.join(token_sep)

      # sha-two-five-six-base-thirty-two-lower-case-no-paddingg
      f_token =
        :crypto.hash(:sha256, token_prehash)
        |> Base.encode32()
        |> String.downcase()
        |> String.trim("=")

      f_token
    end

    def login({username, password}) do
      headers = %{
        user_agent: @user_agent,
        api_key: @api_key,
        device_id: @device_id,
        content_type: "application/json",
        accept: "application/json"
      }

      body =
        Jason.encode!(%{
          username: username,
          password: password
        })

      response = Req.post!("#{@url}/login", body: body, headers: headers)
      %Req.Response{headers: output_headers, body: output_body} = response

      {output_headers, output_body, username}
    end

    def request_mfa({input_headers, input_body, username}) do
      input_headers = Enum.into(input_headers, %{})
      input_body = Enum.into(input_body, %{})
      request_token = Map.get(input_headers, "request-token")
      last_request_id = Map.get(input_headers, "f-request-id")

      f_token_spec = Map.get(input_headers, "f-token-spec")

      f_token_value_map = %{
        "api-key" => @api_key,
        "username" => username,
        "device-id" => @device_id,
        "last-request-id" => last_request_id
      }

      f_token = gen_f_token(f_token_spec, f_token_value_map)

      sms_id =
        input_body
        |> Map.get("devices")
        |> Enum.find(fn x ->
          if Map.get(x, "type") == "SMS", do: true
        end)
        |> Map.get("id")

      headers = %{
        teller_is_hiring: "I know!",
        user_agent: @user_agent,
        api_key: @api_key,
        device_id: @device_id,
        request_token: request_token,
        f_token: f_token,
        content_type: "application/json",
        accept: "application/json"
      }

      body = %{device_id: sms_id} |> Jason.encode!()

      %Req.Response{headers: output_headers, body: output_body} =
        Req.post!("#{@url}/login/mfa/request", body: body, headers: headers)

      {output_headers, username}
    end

    def submit_mfa({input_headers, username}) do
      input_headers = Enum.into(input_headers, %{})
      request_token = Map.get(input_headers, "request-token")
      last_request_id = Map.get(input_headers, "f-request-id")

      f_token_spec = Map.get(input_headers, "f-token-spec")

      f_token_value_map = %{
        "api-key" => @api_key,
        "username" => username,
        "device-id" => @device_id,
        "last-request-id" => last_request_id
      }

      f_token = gen_f_token(f_token_spec, f_token_value_map)

      x_token = BootlegEncDec.transform(username, f_token) |> Base.encode64()

      headers = %{
        x_token: x_token,
        teller_is_hiring: "I know!",
        user_agent: @user_agent,
        api_key: @api_key,
        device_id: @device_id,
        request_token: request_token,
        f_token: f_token,
        content_type: "application/json",
        accept: "application/json"
      }

      body = %{code: @sms_code} |> Jason.encode!()

      response = Req.post!("#{@url}/login/mfa", body: body, headers: headers)
      %Req.Response{headers: output_headers, body: output_body} = response

      {output_headers, output_body, username}
    end

    def get_account_balances({input_headers, input_body, username}) do
      input_headers = Enum.into(input_headers, %{})
      input_body = Enum.into(input_body, %{})
      request_token = Map.get(input_headers, "request-token")
      last_request_id = Map.get(input_headers, "f-request-id")

      f_token_spec = Map.get(input_headers, "f-token-spec")

      f_token_value_map = %{
        "api-key" => @api_key,
        "username" => username,
        "device-id" => @device_id,
        "last-request-id" => last_request_id
      }

      f_token = gen_f_token(f_token_spec, f_token_value_map)

      enc_session = Map.get(input_body, "enc_session_key")

      acc_id =
        input_body["accounts"]["checking"]
        |> Enum.at(0)
        |> Map.get("id")

      headers = %{
        teller_is_hiring: "I know!",
        user_agent: @user_agent,
        api_key: @api_key,
        device_id: @device_id,
        request_token: request_token,
        f_token: f_token,
        accept: "application/json"
      }

      %Req.Response{headers: output_headers, body: output_body} =
        Req.get!("#{@url}/accounts/#{acc_id}/balances", headers: headers)

      {output_headers, output_body, username, acc_id, enc_session}
    end

    def get_account_details({input_headers, input_body, username, acc_id, enc_session}) do
      input_headers = Enum.into(input_headers, %{})
      input_body = Enum.into(input_body, %{})
      request_token = Map.get(input_headers, "request-token")
      last_request_id = Map.get(input_headers, "f-request-id")

      f_token_spec = Map.get(input_headers, "f-token-spec")

      f_token_value_map = %{
        "api-key" => @api_key,
        "username" => username,
        "device-id" => @device_id,
        "last-request-id" => last_request_id
      }

      f_token = gen_f_token(f_token_spec, f_token_value_map)

      available = Map.get(input_body, "available")

      headers = %{
        teller_is_hiring: "I know!",
        user_agent: @user_agent,
        api_key: @api_key,
        device_id: @device_id,
        request_token: request_token,
        f_token: f_token,
        accept: "application/json"
      }

      %Req.Response{body: output_body} =
        Req.get!("#{@url}/accounts/#{acc_id}/details", headers: headers)

      {output_body, enc_session, available}
    end

    def get_balance({input_body, enc_session, available}) do
      input_body = Enum.into(input_body, %{})

      # Map says AES-128 but key is too big looks light AES-256 was intended
      enc_map = enc_session |> Base.decode64!() |> Jason.decode!()
      key = Map.get(enc_map, "key") |> Base.decode64!()
      number = Map.get(input_body, "number") |> Base.decode64!()

      decr_num = :crypto.crypto_one_time(:aes_256_ecb, key, number, false)
      <<_h::binary-32, account_number::binary-12, _t::binary>> = decr_num

      %TellerBank.ChallengeResult{
        account_number: account_number,
        balance_in_cents: to_string(available)
      }
    end

    @spec fetch(username, password) :: ChallengeResult.t()
    def fetch(username, password) do
      {username, password}
      |> login()
      |> request_mfa()
      |> submit_mfa()
      |> get_account_balances()
      |> get_account_details()
      |> get_balance()
    end
  end
end
```

<!-- livebook:{"output":true} -->

```
warning: variable "output_body" is unused (if the variable is not meant to be used, prefix it with an underscore)
  nbs/teller.livemd#cell:g2k27ttrrujq6ewdpzze4vpsck6hene3:100: TellerBank.Client.request_mfa/1

```

<!-- livebook:{"output":true} -->

```
{:module, TellerBank, <<70, 79, 82, 49, 0, 0, 4, ...>>,
 {:module, TellerBank.Client, <<70, 79, 82, ...>>, {:fetch, 2}}}
```

```elixir
username = Kino.Input.read(username)
password = Kino.Input.read(password)

TellerBank.Client.fetch(username, password)
```

<!-- livebook:{"output":true} -->

```
%TellerBank.ChallengeResult{account_number: "745477326035", balance_in_cents: "349782"}
```
